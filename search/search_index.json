{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is currently the fastest BitBuffer for Roblox, and it's currently around 55-75% faster than any of its competition. The API is based on the original module by Stravant, and it is built upon the module made by Defaultio. This documentation site will show you the API and how you can use it. If you want any features, you can create a pull request or you can create an issue on the GitHub.","title":"Home"},{"location":"api/","text":"Global Methods Every method here does support lowerCamelCase as well as PascalCase. You can use that if you choose to. FastBitBuffer.new FastBitBuffer.new() = BitBuffer This will create a new BitBuffer object which can be used to compress any data given down to a much smaller size. FastBitBuffer.BitsRequired FastBitBuffer.BitsRequired(Number: number) = number Calculates the number of bits required for a given number. The equation for calculating this is: $$ \\left \\lceil \\frac{\\log_{10}(x + 1)}{\\log 2} \\right \\rceil $$ BitBuffer API BitBuffer:ResetPointer ResetPointer() = void Resets the BitBuffer's pointer to zero. This is mostly used for the encoding process. BitBuffer:Reset Reset() = void Resets both the BitBuffer's pointer and the BitBuffer data table. BitBuffer:FromString FromString(String: string) = void Reads the string and adds it to the BitBuffer accordingly. Warning This function is not recommended for use because it's quite useless and isn't DataStore ready. BitBuffer:ToString ToString() = string Writes the current data in the BitBuffer to a string. This string isn't useful for anything. Warning This function is not recommended for use because it's quite useless and isn't DataStore ready. BitBuffer:FromBase64 FromBase64(String: string) = void Reads the Base64 string and adds it to the BitBuffer accordingly. Tip This is the recommended way to encode your data. It's guaranteed to be the safest as well as still being fast. BitBuffer:ToBase64 ToBase64() = string Writes the current data in the BitBuffer to a Base64 encoded string. Tip This is the recommended way to encode your data. It's guaranteed to be the safest as well as still being fast. BitBuffer:FromBase128 FromBase128(String: string) = void Reads the Base128 string and adds it to the BitBuffer accordingly. Info This function isn't actually tested, and might not work in DataStores. Use it with caution. It is still very fast despite this. BitBuffer:ToBase128 ToBase128() = string Writes the current data in the BitBuffer to a Base128 encoded string. Info This function isn't actually tested, and might not work in DataStores. Use it with caution. It is still very fast despite this. BitBuffer:Dump Dump() = void Dumps the data inside the BitBuffer and prints it. BitBuffer:WriteUnsigned WriteUnsigned(Width: integer, Value: integer) = void This function writes an unsigned number with a given number of bits. The value must be a positive integer. If the given width is four, the max value that can be stored is calculated as such: \\left [0, 2 ^ 4 - 1 \\right ] = \\left [0, 15 \\right ] \\left [0, 2 ^ 4 - 1 \\right ] = \\left [0, 15 \\right ] Tip If you don't need either negatives or a float, this is the function you should use for maximum compression. BitBuffer:ReadUnsigned ReadUnsigned(Width: integer) = integer This function reads an unsigned number with a given number of bits. BitBuffer:WriteSigned WriteSigned(Width: integer, Value: integer) = void This function is similar to WriteUnsigned , except it writes a signed number, meaning it can store negatives as well. The value must still be an integer. As an example, if the given width is seven, there will be one sign bit and six magnitude bits. \\left [-2 ^ 7 + 1, 2 ^ 7 - 1 \\right ] = \\left [-127, 127 \\right ] \\left [-2 ^ 7 + 1, 2 ^ 7 - 1 \\right ] = \\left [-127, 127 \\right ] BitBuffer:ReadSigned ReadSigned(Width: integer) = integer This function reads a signed number with a given number of bits. BitBuffer:WriteFloat WriteFloat(MantissaWidth: integer, ExponentWidth: integer, Value: number) = void Writes a floating point number to the BitBuffer with a given mantissa and exponent size in bits. Tip You don't really need to call this function unless you want to have faster code at the cost of your sanity and code readability. I recommend using the other float functions instead. BitBuffer:ReadFloat ReadFloat(MantissaWidth: integer, ExponentWidth: integer) = number Reads a floating point number from the BitBuffer with a given mantissa and exponent size in bits. BitBuffer:WriteFloat8 WriteFloat8(Value: number) = void Writes a minifloat to the BitBuffer. Tip This is the smallest method of compressing a float down, but it comes at the cost of number accuracy. If you need more accuracy, use something above this in precision. BitBuffer:ReadFloat8 ReadFloat8() = number Reads a minifloat from the BitBuffer. BitBuffer:WriteFloat16 WriteFloat16(Value: number) = void Writes a half precision floating point number to the BitBuffer. BitBuffer:ReadFloat16 ReadFloat16() = number Reads a half precision floating point number from the BitBuffer. BitBuffer:WriteFloat32 WriteFloat32(Value: number) = void Writes a single precision floating point number to the BitBuffer. Tip This function is the suggested one for storing most floats. If you want to store the player's last height, you should use this function. BitBuffer:ReadFloat32 ReadFloat32() = number Reads a single precision floating point number from the BitBuffer. BitBuffer:WriteFloat64 WriteFloat64(Value: number) = void Writes a double precision floating point number to the BitBuffer. This is the most accurate float function provided, but is also least efficient. Tip If you want to 100% accurately save an arbitrary Lua number, then you should use this function. BitBuffer:ReadFloat64 ReadFloat64() = number Reads a double precision floating point number from the BitBuffer. BitBuffer:WriteBool WriteBool(Boolean: boolean) = void Writes a boolean value to the BitBuffer. Takes only one bit worth of space to store. Alternatively, you can call WriteBoolean for a more accurate name for Lua types. BitBuffer:ReadBool ReadBool() = boolean Reads a boolean value from the BitBuffer. Takes only one bit worth of space to store. Alternatively, you can call ReadBoolean for a more accurate name for Lua types. BitBuffer:WriteString WriteString(String: string) = void Writes a variable length string. The string may contain embedded nulls. Only seven bits / character will be used if the string contains no non-printable characters (greater than 0x80). Note This function doesn't require a width argument because it'll do it for you automatically. BitBuffer:ReadString ReadString() = string Reads a variable length string. The string may contain embedded nulls. Only seven bits / character will be used if the string contains no non-printable characters (greater than 0x80). BitBuffer:WriteBrickColor WriteBrickColor(Color: BrickColor) = void Writes a Roblox BrickColor to the BitBuffer. Provided as an example of reading / writing a derived data type. Danger This function is deprecated and should not be used. Instead, use WriteColor3 instead. BitBuffer:ReadBrickColor ReadBrickColor() = BrickColor Reads a Roblox BrickColor from the BitBuffer. Provided as an example of reading / writing a derived data type. Danger This function is deprecated and should not be used. Instead, use ReadColor3 instead. BitBuffer:WriteColor3 WriteColor3(Color: Color3) = void Writes a Roblox Color3 to the BitBuffer. This is the recommended way to store anything color related in your BitBuffer. BitBuffer:ReadColor3 ReadColor3() = Color3 Reads a Roblox Color3 from the BitBuffer. This is the recommended way to store anything color related in your BitBuffer. BitBuffer:WriteRotation WriteRotation(CoordinateFrame: CFrame) = void Write the rotation part of a given CFrame to the BitBuffer. Encodes the rotation in question into double precision, which is a good size to get a pretty dense packing, but still while having errors well within the threshold that Roblox uses for stuff like MakeJoints() detecting adjacency. Will also perfectly reproduce rotations which are orthagonally aligned, or inverse-power-of-two rotated on only a single axix. For other rotations, the results may not be perfectly stable through read-write cycles (if you read/write an arbitrary rotation thousands of times there may be detectable \"drift\"). Tip If you want to write the entire CFrame, you should use the function WriteCFrame instead. BitBuffer:ReadRotation ReadRotation() = CFrame Reads the rotation part of a given CFrame from the BitBuffer. BitBuffer:WriteVector3 WriteVector3(Vector: Vector3) = void Writes a Vector3 to the BitBuffer using single precision floating points. Alternatve name for this is WriteVector3Float32 . BitBuffer:ReadVector3 ReadVector3() = Vector3 Reads a Vector3 from the BitBuffer. Alternatve name for this is ReadVector3Float32 . BitBuffer:WriteVector3Float64 WriteVector3Float64(Vector: Vector3) = void Writes a Vector3 to the BitBuffer using double precision floating points. For less precision, use WriteVector3 instead. BitBuffer:ReadVector3Float64 ReadVector3Float64() = Vector3 Reads a Vector3 from the BitBuffer. For less precision, use ReadVector3 instead. BitBuffer:WriteVector2 WriteVector2(Vector: Vector2) = void Writes a Vector2 to the BitBuffer using single precision floating points. Alternatve name for this is WriteVector2Float32 . BitBuffer:ReadVector2 ReadVector2() = Vector2 Reads a Vector2 from the BitBuffer. Alternatve name for this is ReadVector2Float32 . BitBuffer:WriteVector2Float64 WriteVector2Float64(Vector: Vector2) = void Writes a Vector2 to the BitBuffer using double precision floating points. For less precision, use WriteVector2 instead. BitBuffer:ReadVector2Float64 ReadVector2Float64() = Vector2 Reads a Vector2 from the BitBuffer. For less precision, use ReadVector2 instead. BitBuffer:WriteCFrame WriteCFrame(CoordinateFrame: CFrame) = void Writes the entire CFrame to the BitBuffer. Uses double precision floating points to do so. BitBuffer:ReadCFrame ReadCFrame() = CFrame Reads an entire CFrame from the BitBuffer. Uses double precision floating points to do so. BitBuffer:WriteUDim2 WriteUDim2(Value: UDim2) = void Writes a UDim2 to the BitBuffer. Uses half precision floating points. BitBuffer:ReadUDim2 ReadUDim2() = UDim2 Reads a UDim2 from the BitBuffer. BitBuffer:Destroy Destroy() = void Destroys the BitBuffer and sets the metatable to nil.","title":"API"},{"location":"api/#global-methods","text":"Every method here does support lowerCamelCase as well as PascalCase. You can use that if you choose to.","title":"Global Methods"},{"location":"api/#fastbitbuffernew","text":"FastBitBuffer.new() = BitBuffer This will create a new BitBuffer object which can be used to compress any data given down to a much smaller size.","title":"FastBitBuffer.new"},{"location":"api/#fastbitbufferbitsrequired","text":"FastBitBuffer.BitsRequired(Number: number) = number Calculates the number of bits required for a given number. The equation for calculating this is: $$ \\left \\lceil \\frac{\\log_{10}(x + 1)}{\\log 2} \\right \\rceil $$","title":"FastBitBuffer.BitsRequired"},{"location":"api/#bitbuffer-api","text":"","title":"BitBuffer API"},{"location":"api/#bitbufferresetpointer","text":"ResetPointer() = void Resets the BitBuffer's pointer to zero. This is mostly used for the encoding process.","title":"BitBuffer:ResetPointer"},{"location":"api/#bitbufferreset","text":"Reset() = void Resets both the BitBuffer's pointer and the BitBuffer data table.","title":"BitBuffer:Reset"},{"location":"api/#bitbufferfromstring","text":"FromString(String: string) = void Reads the string and adds it to the BitBuffer accordingly. Warning This function is not recommended for use because it's quite useless and isn't DataStore ready.","title":"BitBuffer:FromString"},{"location":"api/#bitbuffertostring","text":"ToString() = string Writes the current data in the BitBuffer to a string. This string isn't useful for anything. Warning This function is not recommended for use because it's quite useless and isn't DataStore ready.","title":"BitBuffer:ToString"},{"location":"api/#bitbufferfrombase64","text":"FromBase64(String: string) = void Reads the Base64 string and adds it to the BitBuffer accordingly. Tip This is the recommended way to encode your data. It's guaranteed to be the safest as well as still being fast.","title":"BitBuffer:FromBase64"},{"location":"api/#bitbuffertobase64","text":"ToBase64() = string Writes the current data in the BitBuffer to a Base64 encoded string. Tip This is the recommended way to encode your data. It's guaranteed to be the safest as well as still being fast.","title":"BitBuffer:ToBase64"},{"location":"api/#bitbufferfrombase128","text":"FromBase128(String: string) = void Reads the Base128 string and adds it to the BitBuffer accordingly. Info This function isn't actually tested, and might not work in DataStores. Use it with caution. It is still very fast despite this.","title":"BitBuffer:FromBase128"},{"location":"api/#bitbuffertobase128","text":"ToBase128() = string Writes the current data in the BitBuffer to a Base128 encoded string. Info This function isn't actually tested, and might not work in DataStores. Use it with caution. It is still very fast despite this.","title":"BitBuffer:ToBase128"},{"location":"api/#bitbufferdump","text":"Dump() = void Dumps the data inside the BitBuffer and prints it.","title":"BitBuffer:Dump"},{"location":"api/#bitbufferwriteunsigned","text":"WriteUnsigned(Width: integer, Value: integer) = void This function writes an unsigned number with a given number of bits. The value must be a positive integer. If the given width is four, the max value that can be stored is calculated as such: \\left [0, 2 ^ 4 - 1 \\right ] = \\left [0, 15 \\right ] \\left [0, 2 ^ 4 - 1 \\right ] = \\left [0, 15 \\right ] Tip If you don't need either negatives or a float, this is the function you should use for maximum compression.","title":"BitBuffer:WriteUnsigned"},{"location":"api/#bitbufferreadunsigned","text":"ReadUnsigned(Width: integer) = integer This function reads an unsigned number with a given number of bits.","title":"BitBuffer:ReadUnsigned"},{"location":"api/#bitbufferwritesigned","text":"WriteSigned(Width: integer, Value: integer) = void This function is similar to WriteUnsigned , except it writes a signed number, meaning it can store negatives as well. The value must still be an integer. As an example, if the given width is seven, there will be one sign bit and six magnitude bits. \\left [-2 ^ 7 + 1, 2 ^ 7 - 1 \\right ] = \\left [-127, 127 \\right ] \\left [-2 ^ 7 + 1, 2 ^ 7 - 1 \\right ] = \\left [-127, 127 \\right ]","title":"BitBuffer:WriteSigned"},{"location":"api/#bitbufferreadsigned","text":"ReadSigned(Width: integer) = integer This function reads a signed number with a given number of bits.","title":"BitBuffer:ReadSigned"},{"location":"api/#bitbufferwritefloat","text":"WriteFloat(MantissaWidth: integer, ExponentWidth: integer, Value: number) = void Writes a floating point number to the BitBuffer with a given mantissa and exponent size in bits. Tip You don't really need to call this function unless you want to have faster code at the cost of your sanity and code readability. I recommend using the other float functions instead.","title":"BitBuffer:WriteFloat"},{"location":"api/#bitbufferreadfloat","text":"ReadFloat(MantissaWidth: integer, ExponentWidth: integer) = number Reads a floating point number from the BitBuffer with a given mantissa and exponent size in bits.","title":"BitBuffer:ReadFloat"},{"location":"api/#bitbufferwritefloat8","text":"WriteFloat8(Value: number) = void Writes a minifloat to the BitBuffer. Tip This is the smallest method of compressing a float down, but it comes at the cost of number accuracy. If you need more accuracy, use something above this in precision.","title":"BitBuffer:WriteFloat8"},{"location":"api/#bitbufferreadfloat8","text":"ReadFloat8() = number Reads a minifloat from the BitBuffer.","title":"BitBuffer:ReadFloat8"},{"location":"api/#bitbufferwritefloat16","text":"WriteFloat16(Value: number) = void Writes a half precision floating point number to the BitBuffer.","title":"BitBuffer:WriteFloat16"},{"location":"api/#bitbufferreadfloat16","text":"ReadFloat16() = number Reads a half precision floating point number from the BitBuffer.","title":"BitBuffer:ReadFloat16"},{"location":"api/#bitbufferwritefloat32","text":"WriteFloat32(Value: number) = void Writes a single precision floating point number to the BitBuffer. Tip This function is the suggested one for storing most floats. If you want to store the player's last height, you should use this function.","title":"BitBuffer:WriteFloat32"},{"location":"api/#bitbufferreadfloat32","text":"ReadFloat32() = number Reads a single precision floating point number from the BitBuffer.","title":"BitBuffer:ReadFloat32"},{"location":"api/#bitbufferwritefloat64","text":"WriteFloat64(Value: number) = void Writes a double precision floating point number to the BitBuffer. This is the most accurate float function provided, but is also least efficient. Tip If you want to 100% accurately save an arbitrary Lua number, then you should use this function.","title":"BitBuffer:WriteFloat64"},{"location":"api/#bitbufferreadfloat64","text":"ReadFloat64() = number Reads a double precision floating point number from the BitBuffer.","title":"BitBuffer:ReadFloat64"},{"location":"api/#bitbufferwritebool","text":"WriteBool(Boolean: boolean) = void Writes a boolean value to the BitBuffer. Takes only one bit worth of space to store. Alternatively, you can call WriteBoolean for a more accurate name for Lua types.","title":"BitBuffer:WriteBool"},{"location":"api/#bitbufferreadbool","text":"ReadBool() = boolean Reads a boolean value from the BitBuffer. Takes only one bit worth of space to store. Alternatively, you can call ReadBoolean for a more accurate name for Lua types.","title":"BitBuffer:ReadBool"},{"location":"api/#bitbufferwritestring","text":"WriteString(String: string) = void Writes a variable length string. The string may contain embedded nulls. Only seven bits / character will be used if the string contains no non-printable characters (greater than 0x80). Note This function doesn't require a width argument because it'll do it for you automatically.","title":"BitBuffer:WriteString"},{"location":"api/#bitbufferreadstring","text":"ReadString() = string Reads a variable length string. The string may contain embedded nulls. Only seven bits / character will be used if the string contains no non-printable characters (greater than 0x80).","title":"BitBuffer:ReadString"},{"location":"api/#bitbufferwritebrickcolor","text":"WriteBrickColor(Color: BrickColor) = void Writes a Roblox BrickColor to the BitBuffer. Provided as an example of reading / writing a derived data type. Danger This function is deprecated and should not be used. Instead, use WriteColor3 instead.","title":"BitBuffer:WriteBrickColor"},{"location":"api/#bitbufferreadbrickcolor","text":"ReadBrickColor() = BrickColor Reads a Roblox BrickColor from the BitBuffer. Provided as an example of reading / writing a derived data type. Danger This function is deprecated and should not be used. Instead, use ReadColor3 instead.","title":"BitBuffer:ReadBrickColor"},{"location":"api/#bitbufferwritecolor3","text":"WriteColor3(Color: Color3) = void Writes a Roblox Color3 to the BitBuffer. This is the recommended way to store anything color related in your BitBuffer.","title":"BitBuffer:WriteColor3"},{"location":"api/#bitbufferreadcolor3","text":"ReadColor3() = Color3 Reads a Roblox Color3 from the BitBuffer. This is the recommended way to store anything color related in your BitBuffer.","title":"BitBuffer:ReadColor3"},{"location":"api/#bitbufferwriterotation","text":"WriteRotation(CoordinateFrame: CFrame) = void Write the rotation part of a given CFrame to the BitBuffer. Encodes the rotation in question into double precision, which is a good size to get a pretty dense packing, but still while having errors well within the threshold that Roblox uses for stuff like MakeJoints() detecting adjacency. Will also perfectly reproduce rotations which are orthagonally aligned, or inverse-power-of-two rotated on only a single axix. For other rotations, the results may not be perfectly stable through read-write cycles (if you read/write an arbitrary rotation thousands of times there may be detectable \"drift\"). Tip If you want to write the entire CFrame, you should use the function WriteCFrame instead.","title":"BitBuffer:WriteRotation"},{"location":"api/#bitbufferreadrotation","text":"ReadRotation() = CFrame Reads the rotation part of a given CFrame from the BitBuffer.","title":"BitBuffer:ReadRotation"},{"location":"api/#bitbufferwritevector3","text":"WriteVector3(Vector: Vector3) = void Writes a Vector3 to the BitBuffer using single precision floating points. Alternatve name for this is WriteVector3Float32 .","title":"BitBuffer:WriteVector3"},{"location":"api/#bitbufferreadvector3","text":"ReadVector3() = Vector3 Reads a Vector3 from the BitBuffer. Alternatve name for this is ReadVector3Float32 .","title":"BitBuffer:ReadVector3"},{"location":"api/#bitbufferwritevector3float64","text":"WriteVector3Float64(Vector: Vector3) = void Writes a Vector3 to the BitBuffer using double precision floating points. For less precision, use WriteVector3 instead.","title":"BitBuffer:WriteVector3Float64"},{"location":"api/#bitbufferreadvector3float64","text":"ReadVector3Float64() = Vector3 Reads a Vector3 from the BitBuffer. For less precision, use ReadVector3 instead.","title":"BitBuffer:ReadVector3Float64"},{"location":"api/#bitbufferwritevector2","text":"WriteVector2(Vector: Vector2) = void Writes a Vector2 to the BitBuffer using single precision floating points. Alternatve name for this is WriteVector2Float32 .","title":"BitBuffer:WriteVector2"},{"location":"api/#bitbufferreadvector2","text":"ReadVector2() = Vector2 Reads a Vector2 from the BitBuffer. Alternatve name for this is ReadVector2Float32 .","title":"BitBuffer:ReadVector2"},{"location":"api/#bitbufferwritevector2float64","text":"WriteVector2Float64(Vector: Vector2) = void Writes a Vector2 to the BitBuffer using double precision floating points. For less precision, use WriteVector2 instead.","title":"BitBuffer:WriteVector2Float64"},{"location":"api/#bitbufferreadvector2float64","text":"ReadVector2Float64() = Vector2 Reads a Vector2 from the BitBuffer. For less precision, use ReadVector2 instead.","title":"BitBuffer:ReadVector2Float64"},{"location":"api/#bitbufferwritecframe","text":"WriteCFrame(CoordinateFrame: CFrame) = void Writes the entire CFrame to the BitBuffer. Uses double precision floating points to do so.","title":"BitBuffer:WriteCFrame"},{"location":"api/#bitbufferreadcframe","text":"ReadCFrame() = CFrame Reads an entire CFrame from the BitBuffer. Uses double precision floating points to do so.","title":"BitBuffer:ReadCFrame"},{"location":"api/#bitbufferwriteudim2","text":"WriteUDim2(Value: UDim2) = void Writes a UDim2 to the BitBuffer. Uses half precision floating points.","title":"BitBuffer:WriteUDim2"},{"location":"api/#bitbufferreadudim2","text":"ReadUDim2() = UDim2 Reads a UDim2 from the BitBuffer.","title":"BitBuffer:ReadUDim2"},{"location":"api/#bitbufferdestroy","text":"Destroy() = void Destroys the BitBuffer and sets the metatable to nil.","title":"BitBuffer:Destroy"},{"location":"guide/installation/","text":"There's really only one way to install this module. I recommend that you put it in your ServerStorage , as it's the perfect place for storing ModuleScripts, and it's only meant for use on the server. To install, just run this in your Studio command line. local ServerStorage = game : GetService ( ServerStorage ) local installer = require ( 4300858244 ) local FastBitBuffer = installer : Install ( https://github.com/howmanysmall/FastBitBuffer/tree/master/src , ServerStorage ) FastBitBuffer . Name = FastBitBuffer","title":"Installation"},{"location":"guide/location/","text":"This page will show you how to save the player's last location using FastBitBuffer and DataStore2 . This assumes you already have it installed and it is located in ServerStorage . If you want to see it in action, the place is right here . local Players = game : GetService ( Players ) local ServerStorage = game : GetService ( ServerStorage ) local DataStore2 = require ( ServerStorage . DataStore2 ) local FastBitBuffer = require ( ServerStorage . FastBitBuffer ) local DATA_STORE_NAME = LastPlayerLocation local RAISED_VECTOR3 = Vector3 . new ( 0 , 3 , 0 ) local DEFAULT_PLAYER_SPAWN_CFRAME = CFrame . new ( 0 , 6 , 0 ) local DEFAULT_PLAYER_SPAWN_BASE64 do local bitBuffer = FastBitBuffer . new () bitBuffer : WriteCFrame ( DEFAULT_PLAYER_SPAWN_CFRAME ) DEFAULT_PLAYER_SPAWN_BASE64 = bitBuffer : ToBase64 () bitBuffer : Destroy () bitBuffer = nil end local playerLocations = {} local function beforeInitialGet ( serialized ) local bitBuffer = FastBitBuffer . new () bitBuffer : FromBase64 ( serialized ) local deserialized = bitBuffer : ReadCFrame () bitBuffer : Destroy () bitBuffer = nil return deserialized end local function beforeSave ( deserialized ) local bitBuffer = FastBitBuffer . new () bitBuffer : WriteCFrame ( deserialized ) local serialized = bitBuffer : ToBase64 () bitBuffer : Destroy () bitBuffer = nil return serialized end local function onUpdate ( player ) return function ( playerLocation ) playerLocations [ player ] = playerLocation end end local function characterRemoving ( player ) return function ( character ) local humanoid = character : FindFirstChildOfClass ( Humanoid ) if humanoid and humanoid . Health 0 then local playerLocation = DataStore2 ( DATA_STORE_NAME , player ) playerLocation : Set ( character : GetPrimaryPartCFrame ()) end end end local function playerAdded ( player ) if not playerLocations [ player ] then player . CharacterRemoving : Connect ( characterRemoving ( player )) local playerLocation = DataStore2 ( DATA_STORE_NAME , player ) playerLocation : BeforeInitialGet ( beforeInitialGet ) playerLocation : BeforeSave ( beforeSave ) playerLocation : OnUpdate ( onUpdate ( player )) local defaultLocation = playerLocation : Get ( DEFAULT_PLAYER_SPAWN_BASE64 ) if type ( defaultLocation ) == string then defaultLocation = beforeInitialGet ( defaultLocation ) end local character = player . Character or player . CharacterAdded : Wait () character : WaitForChild ( HumanoidRootPart ) character : SetPrimaryPartCFrame ( defaultLocation + RAISED_VECTOR3 ) end end local function playerRemoving ( player ) if playerLocations [ player ] then playerLocations [ player ] = nil end end Players . PlayerAdded : Connect ( playerAdded ) Players . PlayerRemoving : Connect ( playerRemoving ) for _ , player in ipairs ( Players : GetPlayers ()) do playerAdded ( player ) end","title":"Example: Saving Locations"},{"location":"guide/usage/","text":"The purpose of this module is to save and load data with an incredible compression ratio. The basic usage of it can be seen in the following code. What this code does is: Checks if the Player already has Leaderstats when the PlayerAdded function is called. If they don't have it, create a new BitBuffer. After the BitBuffer is created, check if they have any data saved on the DataStore. If they don't have any, set their data to the default created at the start of the script. Loads their data from the Base64 string that is stored in the DataStore using FromBase64 . Create the Leaderstats using the loadFromBitBuffer , which reads the Color3 first, and then the unsigned number second because that's what order they are stored in. Parents the Leaderstats returned by loadFromBitBuffer to the Player. When the player leaves, check if they have Leaderstats. If they do, create a new BitBuffer. Run the saveToBitBuffer function, which calls WriteColor3 first followed by WriteUnsigned . Sets the new data using SetAsync and ToBase64 . Once that is complete, we call Destroy on the BitBuffer and set it to nil. Important The order of which you read and write does matter. If you don't follow the same order, your data will not be correct. Error I do not recommend using the data saving part of this example in your code. Instead, it's suggested to use either DataStore2 or Quenty's DataStore system . local Players = game : GetService ( Players ) local ServerStorage = game : GetService ( ServerStorage ) local DataStoreService = game : GetService ( DataStoreService ) local FastBitBuffer = require ( ServerStorage . FastBitBuffer ) local USER_DATA = { FavoriteColor , Stage } local TOTAL_STAGES = 400 local BITS_REQUIRED = FastBitBuffer . BitsRequired ( TOTAL_STAGES ) local DEFAULT_DATA do local bitBuffer = FastBitBuffer . new () bitBuffer : WriteColor3 ( Color3 . new ()) bitBuffer : WriteUnsigned ( BITS_REQUIRED , 1 ) DEFAULT_DATA = bitBuffer : ToBase64 () bitBuffer : Destroy () bitBuffer = nil end local gameDataStore = DataStoreService : GetDataStore ( GameDataStore ) local function saveToBitBuffer ( bitBuffer , leaderstats ) for _ , valueName in ipairs ( USER_DATA ) do assert ( leaderstats : FindFirstChild ( valueName ), string.format ( Expected ValueObject %s to exist but it doesn t. , valueName )) end bitBuffer : WriteColor3 ( leaderstats . favoriteColor . Value ) bitBuffer : WriteUnsigned ( BITS_REQUIRED , leaderstats . Stage . Value ) end local function loadFromBitBuffer ( bitBuffer ) local leaderstats = Instance . new ( Folder ) leaderstats . Name = Leaderstats local favoriteColor = Instance . new ( Color3Value ) favoriteColor . Name = FavoriteColor favoriteColor . Value = bitBuffer : ReadColor3 () favoriteColor . Parent = leaderstats local stage = Instance . new ( IntValue ) stage . Name = Stage stage . Value = bitBuffer : ReadUnsigned ( BITS_REQUIRED ) stage . Parent = leaderstats return leaderstats end local function playerAdded ( player ) if not player : FindFirstChild ( Leaderstats ) then local bitBuffer = FastBitBuffer . new () local success , playerData = pcall ( gameDataStore . GetAsync , gameDataStore , player . UserId ) if success then if not playerData then playerData = DEFAULT_DATA pcall ( gameDataStore . SetAsync , gameDataStore , player . UserId , playerData ) end bitBuffer : FromBase64 ( playerData ) local leaderstats = loadFromBitBuffer ( bitBuffer ) leaderstats . Parent = player bitBuffer : Destroy () bitBuffer = nil end end end local function playerRemoving ( player ) local leaderstats = player : FindFirstChild ( Leaderstats ) if leaderstats then local bitBuffer = FastBitBuffer . new () saveToBitBuffer ( bitBuffer , leaderstats ) local success , error = pcall ( gameDataStore . SetAsync , gameDataStore , player . UserId , bitBuffer : ToBase64 ()) if not success and error then warn ( Failed to save PlayerData! , error ) end bitBuffer : Destroy () bitBuffer = nil end end Players . PlayerAdded : Connect ( playerAdded ) Players . PlayerRemoving : Connect ( playerRemoving ) for _ , player in ipairs ( Players : GetPlayers ()) do playerAdded ( player ) end","title":"Usage"}]}